# egret-statemachine
基于Egret开发的状态机（StateMachine）

# 为什么使用该项目？
该项目创立是因为在我们的项目当中有着无数的状态机、启动和禁用UI元素、抽象设备和业务逻辑。使用状态模式实现这些状态机过于复杂。因此，我准备实现了一个状态机组建，允许将状态机实现为单个类。这样就可以大大降低复杂性和所需的工作量。

# 实现功能

- [ ] 使用枚举，数值型，字符串或自己的类来处理状态和事件 - 从而产生单类状态机。
- [ ] 过渡、进入和离开动作
- [ ] 过渡保护
- [ ] 具有历史行为的分层状态，以将状态始终初始化为相同的状态或最后的活动状态。
- [ ] 支持async/await
- [ ] 流畅的定义语法
- [ ] 被动状态机同步处理状态转换
- [ ] 活动状态机在状态机的工作现成上异步处理状态转换
- [ ] 扩展支持扩展状态机的功能
- [ ] 可扩展的日志记录
- [ ] 状态报告为text, csv或 yEd图。

# 设计
## 状态机（StateMachine）
它应包含两个不同的状态机。

- 被动状态机
- 活动状态机

所有的状态机都应实现IStateMachine接口。为了更好的可测试性和灵活性，应当只通过接口引用状态机，并使用依赖注入来获取这两种实现。这样就可以再测试中使用被动状态机来代替主动状态机来简化测试。因为所有操作都在同一个线程上运行。

## 状态和事件

状态机是使用状态和事件定义的。状态和事件必须是IComparables（枚举、number、字符串…）。如果您有一组众所周知的状态和事件，那么应当使用使代码可读性更好的枚举。如果计划在状态机中构建一些灵活性（例如，添加状态、基类中的转换），那么最好使用“开放”类型，如字符串、数值。

## 转换（Transitions）

转换是响应在状态机上激发的事件而执行的状态开关。您可以定义每个状态和事件进行哪个转换，从而确定要转到哪个状态。

## 动作（Actions）

您可以定义转换或状态进入或退出时的操作。当将转换作为对事件的响应时，将执行转换操作。当状态机由于执行的转换而进入或退出状态时，将执行状态的进入和退出操作。在分层状态下，可以执行多个进入和退出操作。

## 保护（Guards）

可以根据布尔条件决定执行哪种转换。当一个事件被激发到状态机上时，它将获取在当前状态中为被激发事件定义的所有转换，并执行第一个转换，同时返回true。

## 扩展（Extensions）

扩展可用于扩展状态机的功能。例如，提供了一种简单的方法来编写记录器。

## 报告

开箱即用，提供文本报告，csv报告和yEd图。 只需实现IStateMachineReport即可添加自己的报告。